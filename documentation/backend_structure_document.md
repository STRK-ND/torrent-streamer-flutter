# Backend Structure Document

This document outlines the backend architecture, database setup, API design, hosting environment, infrastructure components, security practices, and maintenance strategies for the `torrent-streamer-flutter` backend service.

## 1. Backend Architecture

Overall, the backend follows an **API-first**, serverless-friendly design built on **Next.js 15** with the App Router. It emphasizes modularity, type safety, and clear separation of concerns:

- Framework & Patterns:
  - Next.js 15 (App Router) for folder-based routing of API endpoints
  - Controllers, services, and data layers kept in separate folders
  - Middleware for cross-cutting concerns (authentication, logging)
  - Repository pattern via Drizzle ORM for database interactions
- Scalability & Performance:
  - Hosted as serverless functions (Vercel), auto-scaling with demand
  - TypeScript and Drizzle ORM ensure compile-time checks and fewer runtime errors
  - Stateless functions make horizontal scaling trivial
- Maintainability:
  - Clear folder structure: `/app/api`, `/db/schema`, `/lib`, `/components`
  - End-to-end type safety (TypeScript + Drizzle) prevents schema drift
  - Docker configuration maintains parity between dev and prod

## 2. Database Management

We use a relational database to store structured data. All interactions use Drizzle ORM for type-safe queries.

- Database Type: SQL
- System: PostgreSQL
- ORM: Drizzle ORM (TypeScript-based)
- Data Practices:
  - Schemas defined in code, migrations generated by Drizzle Kit
  - Connection pooling handled by the hosting environment or PgBouncer in Docker
  - Environment variables store database credentials securely
  - Daily backups and point-in-time recovery via managed Postgres service

## 3. Database Schema

The main entities and their fields are described below. Following that is the SQL schema for PostgreSQL.

Human-Readable Entity Definitions:

- **Users**: Stores user profiles and credentials
  - id (UUID)
  - email (unique string)
  - password_hash (string)
  - role (enum: user, admin)
  - created_at, updated_at (timestamps)

- **Torrents**: Metadata for each scraped torrent
  - id (UUID)
  - info_hash (string, unique)
  - name (string)
  - size_bytes (integer)
  - poster_url (string)
  - created_at (timestamp)

- **Files**: Individual files belonging to a torrent
  - id (UUID)
  - torrent_id (UUID, foreign key to Torrents)
  - file_name (string)
  - file_size (integer)
  - file_index (integer)

- **WatchHistory**: Tracks what users have watched
  - id (UUID)
  - user_id (UUID, foreign key to Users)
  - torrent_id (UUID, foreign key to Torrents)
  - watched_at (timestamp)
  - progress_percent (integer)

- **Preferences**: User-specific settings
  - id (UUID)
  - user_id (UUID, foreign key to Users)
  - key (string)
  - value (string)

PostgreSQL Schema (SQL):

```sql
-- Users table
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email TEXT NOT NULL UNIQUE,
  password_hash TEXT NOT NULL,
  role TEXT NOT NULL DEFAULT 'user',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Torrents table
CREATE TABLE torrents (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  info_hash TEXT NOT NULL UNIQUE,
  name TEXT NOT NULL,
  size_bytes BIGINT NOT NULL,
  poster_url TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Files table
CREATE TABLE files (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  torrent_id UUID REFERENCES torrents(id) ON DELETE CASCADE,
  file_name TEXT NOT NULL,
  file_size BIGINT NOT NULL,
  file_index INTEGER NOT NULL
);

-- WatchHistory table
CREATE TABLE watch_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  torrent_id UUID REFERENCES torrents(id) ON DELETE CASCADE,
  watched_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  progress_percent INTEGER NOT NULL DEFAULT 0
);

-- Preferences table
CREATE TABLE preferences (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  key TEXT NOT NULL,
  value TEXT NOT NULL
);
``` 

## 4. API Design and Endpoints

The backend exposes a RESTful API. All routes live under `/app/api`. Requests and responses use JSON, and input is validated with Zod.

### Authentication

- **POST /api/auth/sign-up**  
  Registers a new user. Returns a JWT access token.
- **POST /api/auth/sign-in**  
  Authenticates existing user. Returns a JWT access token.
- **GET /api/auth/me**  
  Retrieves the authenticated user’s profile. Requires valid token.

### Torrent APIs

- **GET /api/torrents/search?q={query}**  
  Returns a list of torrents matching the search query.
- **GET /api/torrents/latest**  
  Returns the most recently added torrents.
- **GET /api/torrents/{id}**  
  Retrieves detailed metadata (including file list) for one torrent.

### User & History

- **GET /api/users/me**  
  Returns the current user’s profile and preferences.
- **POST /api/watch-history**  
  Records or updates a user’s watch progress for a torrent.

### Data Ingestion

- **POST /api/ingest**  
  Secured endpoint for Cloudflare Worker to push newly scraped torrent metadata.
  - Requires an API key in headers
  - Accepts batch of torrent records

## 5. Hosting Solutions

- **Compute:** Vercel serverless functions
  - Automatic scaling based on request volume
  - Zero-configuration SSL and global edge distribution
- **Database Host:** Managed PostgreSQL (e.g., Neon, Supabase, or AWS RDS)
  - Automated backups, high availability, and read replicas
- **Local & CI:** Docker Compose for Postgres and Node.js
  - Ensures dev environment matches production

Benefits:
- High reliability with Vercel and managed Postgres SLAs
- Cost-effective: pay-per-use for serverless functions
- Low ops overhead: automatic OS and framework updates

## 6. Infrastructure Components

- **Load Balancer & Edge:** Provided by Vercel, routes requests to nearest serverless region
- **CDN:** Vercel Edge Network and optional Cloudflare proxy
- **Caching:**
  - HTTP cache headers on GET endpoints
  - Edge caching for static or infrequently changing data
  - In-memory or Redis cache (optional) for hot database queries
- **Queue/Jobs:**
  - Vercel Cron or Inngest for scheduled scraping triggers
  - Worker queue for heavy data processing (optional)

## 7. Security Measures

- **Authentication & Authorization:**
  - JSON Web Tokens (JWT) issued at login
  - Middleware enforces protected routes and role-based access
- **Encryption:**
  - TLS/HTTPS for all client-server and service-to-service traffic
  - Database encrypted at rest by the managed provider
- **Input Validation:**
  - Zod schemas validate every request body, query, and path parameter
- **Secrets Management:**
  - Environment variables (.env) stored in Vercel’s secret vault or CI secrets
- **Rate Limiting & Abuse Protection:** (optional)
  - Basic rate-limiter middleware to prevent brute-force or scraping attacks

## 8. Monitoring and Maintenance

- **Logging:**
  - Structured logs (JSON) sent to Logtail or Datadog
  - Vercel function logs accessible in dashboard
- **Error Tracking:**
  - Sentry integration for runtime exceptions and performance monitoring
- **Metrics & Alerts:**
  - Vercel Analytics for request timing and error rates
  - Database performance metrics via provider dashboard
- **Maintenance Strategies:**
  - Automated schema migrations with Drizzle Kit
  - Dependency updates via Dependabot or Renovate
  - Regular database vacuuming and index maintenance (managed automatically)

## 9. Conclusion and Overall Backend Summary

This backend is designed to be a **scalable**, **maintainable**, and **secure** foundation for your Flutter-based torrent streaming application. By leveraging Next.js serverless functions, a type-safe Drizzle ORM layer, and a managed PostgreSQL database, you get:

- Rapid API development with end-to-end TypeScript safety
- Seamless scaling and zero-downtime deployments on Vercel
- Robust authentication, data validation, and monitoring
- Clear separation between data ingestion (Cloudflare Worker) and API serving

Together, these components ensure you can focus on building an excellent mobile streaming experience, confident that the backend infrastructure is rock solid.